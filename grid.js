// Generated by CoffeeScript 1.10.0
var Grid, arrayExcept, display, eye, grid, hasAll, hasNone, inRect, indTranspo, isBetween, isntBetween, mainController, oxLib, permute, pretty, prettyPerm, rects, states, transpos, transpose, xoCount;

Grid = angular.module('Grid', []);

mainController = function($scope, $http) {
  $scope.n = 4;
  $scope.states = [];
  $scope.transpos = [];
  return $scope.rects = [];
};

arrayExcept = function(arr, i) {
  var result;
  result = arr.slice(0);
  result.splice(i, 1);
  return result;
};

permute = function(arr) {
  var i, perm, permutations, ref, value;
  arr = Array.prototype.slice.call(arr, 0);
  if (arr.length === 0) {
    return [[]];
  }
  permutations = (function() {
    var l, len, results;
    results = [];
    for (i = l = 0, len = arr.length; l < len; i = ++l) {
      value = arr[i];
      results.push((function() {
        var len1, m, ref, results1;
        ref = permute(arrayExcept(arr, i));
        results1 = [];
        for (m = 0, len1 = ref.length; m < len1; m++) {
          perm = ref[m];
          results1.push([value].concat(perm));
        }
        return results1;
      })());
    }
    return results;
  })();
  return (ref = []).concat.apply(ref, permutations);
};

states = [];

transpos = [];

rects = [];

indTranspo = function(n, t) {
  return t[0] * (2 * n - 3 - t[0]) / 2 - 1 + t[1];
};

grid = function(oxPerms) {
  var aa, ab, alex, base, base1, col, computable, computables, grading, i, j, k, l, len, len1, len2, len3, len4, len5, len6, m, mo, mx, n, nchoose2, o, oPerm, oPoints, r, rect, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, results, results1, s, state, stateInd, statePoints, transpo, transpoInd, u, v, v1, v2, w, x, xPerm, xPoints, y, z;
  oPerm = oxPerms[0], xPerm = oxPerms[1];
  n = oPerm.length;
  if (states[n] == null) {
    states[n] = permute((function() {
      results = [];
      for (var l = 1; 1 <= n ? l <= n : l >= n; 1 <= n ? l++ : l--){ results.push(l); }
      return results;
    }).apply(this));
    transpos[n] = [];
    for (i = m = 0, ref = n; 0 <= ref ? m < ref : m > ref; i = 0 <= ref ? ++m : --m) {
      for (j = o = ref1 = i + 1, ref2 = n; ref1 <= ref2 ? o < ref2 : o > ref2; j = ref1 <= ref2 ? ++o : --o) {
        transpos[n].push([i, j]);
      }
    }
    rects[n] = [];
    ref3 = states[n];
    for (stateInd = r = 0, len = ref3.length; r < len; stateInd = ++r) {
      state = ref3[stateInd];
      rects[n][stateInd] = [];
      for (i = s = 0, ref4 = n; 0 <= ref4 ? s < ref4 : s > ref4; i = 0 <= ref4 ? ++s : --s) {
        for (j = u = ref5 = i + 1, ref6 = n; ref5 <= ref6 ? u < ref6 : u > ref6; j = ref5 <= ref6 ? ++u : --u) {
          v1 = [i, state[i]];
          v2 = [j, state[j]];
          if (hasNone(v1, v2, (function() {
            var ref7, ref8, results1, v;
            results1 = [];
            for (k = v = ref7 = i + 1, ref8 = j; v < ref8; k = v += 1) {
              results1.push([k, state[k]]);
            }
            return results1;
          })())) {
            rects[n][stateInd].push(indTranspo(n, [i, j]));
          }
          if (hasNone(v2, v1, (function() {
            var len1, ref7, ref8, results1, results2, results3, v, w, x;
            ref8 = (function() {
              results3 = [];
              for (var x = 0; 0 <= i ? x < i : x > i; 0 <= i ? x++ : x--){ results3.push(x); }
              return results3;
            }).apply(this).concat((function() {
              results2 = [];
              for (var w = ref7 = j + 1; ref7 <= n ? w < n : w > n; ref7 <= n ? w++ : w--){ results2.push(w); }
              return results2;
            }).apply(this));
            results1 = [];
            for (v = 0, len1 = ref8.length; v < len1; v += 1) {
              k = ref8[v];
              results1.push([k, state[k]]);
            }
            return results1;
          })())) {
            rects[n][stateInd].push(indTranspo(n, [i, j]) + n * (n - 1) / 2);
          }
        }
      }
    }
  }
  oPoints = (function() {
    var len1, results1, v;
    results1 = [];
    for (i = v = 0, len1 = oPerm.length; v < len1; i = ++v) {
      y = oPerm[i];
      results1.push([i + .5, y - .5]);
    }
    return results1;
  })();
  xPoints = (function() {
    var len1, results1, v;
    results1 = [];
    for (i = v = 0, len1 = xPerm.length; v < len1; i = ++v) {
      y = xPerm[i];
      results1.push([i + .5, y - .5]);
    }
    return results1;
  })();
  col = 3;
  computables = [
    {
      name: "d",
      none: xPoints,
      all: []
    }, {
      name: "Hx",
      none: arrayExcept(xPoints, col - 1),
      all: [xPoints[col - 1]]
    }, {
      name: "Ho",
      none: xPoints,
      all: [oPoints[col - 1]]
    }, {
      name: "Hxo",
      none: arrayExcept(xPoints, col - 1),
      all: [xPoints[col - 1], oPoints[col - 1]]
    }
  ];
  for (v = 0, len1 = computables.length; v < len1; v++) {
    computable = computables[v];
    computable.result = [];
  }
  grading = [];
  ref7 = states[n];
  for (stateInd = w = 0, len2 = ref7.length; w < len2; stateInd = ++w) {
    state = ref7[stateInd];
    statePoints = (function() {
      var len3, results1, x;
      results1 = [];
      for (i = x = 0, len3 = state.length; x < len3; i = ++x) {
        y = state[i];
        results1.push([i, y - 1]);
      }
      return results1;
    })();
    mo = eye(statePoints, statePoints) - eye(statePoints, oPoints) - eye(oPoints, statePoints) + eye(oPoints, oPoints) + 1;
    mx = eye(statePoints, statePoints) - eye(statePoints, xPoints) - eye(xPoints, statePoints) + eye(xPoints, xPoints) + 1;
    alex = (mo - mx - n + 1) / 2;
    grading[stateInd] = [mo, alex];
    console.log("[" + (state.join('')) + "]: M = " + mo + ", A = " + alex);
    for (x = 0, len3 = computables.length; x < len3; x++) {
      computable = computables[x];
      if ((base = computable.result)[stateInd] == null) {
        base[stateInd] = [];
      }
    }
    ref8 = rects[n][stateInd];
    for (z = 0, len4 = ref8.length; z < len4; z++) {
      rect = ref8[z];
      nchoose2 = n * (n - 1) / 2;
      transpoInd = rect % nchoose2;
      transpo = transpos[n][transpoInd];
      v1 = statePoints[transpo[0]];
      v2 = statePoints[transpo[1]];
      for (aa = 0, len5 = computables.length; aa < len5; aa++) {
        computable = computables[aa];
        if ((base1 = computable.result[stateInd])[transpoInd] == null) {
          base1[transpoInd] = [];
        }
        if (rect < nchoose2) {
          if (hasNone(v1, v2, computable.none) && hasAll(v1, v2, computable.all)) {
            computable.result[stateInd][transpoInd][0] = pretty(xoCount(v1, v2, oPoints));
          }
        } else {
          if (hasNone(v2, v1, computable.none) && hasAll(v2, v1, computable.all)) {
            computable.result[stateInd][transpoInd][1] = pretty(xoCount(v2, v1, oPoints));
          }
        }
      }
    }
  }
  results1 = [];
  for (ab = 0, len6 = computables.length; ab < len6; ab++) {
    computable = computables[ab];
    results1.push(display(n, computable.name, computable.result));
  }
  return results1;
};

display = function(n, name, thing) {
  var answer, i, j, l, m, ref, ref1, results, transpo, transpoStr;
  results = [];
  for (i = l = 0, ref = thing.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
    answer = [];
    for (j = m = 0, ref1 = thing[i].length; 0 <= ref1 ? m < ref1 : m > ref1; j = 0 <= ref1 ? ++m : --m) {
      transpoStr = transpose(states[n][i], transpos[n][j]);
      if (thing[i][j] != null) {
        transpo = thing[i][j];
        if (transpo[0] === void 0) {
          if (transpo[1] !== void 0) {
            answer.push((transpo[1] === "1" ? "" : transpo[1]) + transpoStr);
          }
        } else {
          if (transpo[1] === void 0) {
            answer.push((transpo[0] === "1" ? "" : transpo[0]) + transpoStr);
          } else {
            answer.push("(" + transpo[0] + "+" + transpo[1] + ")" + transpoStr);
          }
        }
      }
    }
    results.push(console.log("" + name + (prettyPerm(states[n][i])) + " = " + (answer.join(' + '))));
  }
  return results;
};

transpose = function(state, transpo) {
  var dummy, temp;
  temp = state.slice(0);
  dummy = temp[transpo[0]];
  temp[transpo[0]] = temp[transpo[1]];
  temp[transpo[1]] = dummy;
  return prettyPerm(temp);
};

prettyPerm = function(state) {
  if (state.length < 10) {
    return "[" + (state.join('')) + "]";
  } else {
    return JSON.stringify(state);
  }
};

isBetween = function(a, b, c) {
  return a < b && b < c;
};

isntBetween = function(a, b, c) {
  return b < a || b > c;
};

inRect = function(sw, ne, p) {
  if (sw[0] < ne[0]) {
    if (sw[1] < ne[1]) {
      return isBetween(sw[0], p[0], ne[0]) && isBetween(sw[1], p[1], ne[1]);
    } else {
      return isBetween(sw[0], p[0], ne[0]) && isntBetween(ne[1], p[1], sw[1]);
    }
  } else {
    if (sw[1] < ne[1]) {
      return isntBetween(ne[0], p[0], sw[0]) && isBetween(sw[1], p[1], ne[1]);
    } else {
      return isntBetween(ne[0], p[0], sw[0]) && isntBetween(ne[1], p[1], sw[1]);
    }
  }
};

eye = function(aPoints, bPoints) {
  var a, b, counter, l, len, len1, m;
  counter = 0;
  for (l = 0, len = aPoints.length; l < len; l++) {
    a = aPoints[l];
    for (m = 0, len1 = bPoints.length; m < len1; m++) {
      b = bPoints[m];
      if (a[0] < b[0] && a[1] < b[1]) {
        counter += 1;
      }
    }
  }
  return counter;
};

xoCount = function(sw, ne, points) {
  var l, len, p, result;
  result = [];
  for (l = 0, len = points.length; l < len; l++) {
    p = points[l];
    result.push(inRect(sw, ne, p));
  }
  return result;
};

hasAll = function(sw, ne, points) {
  var l, len, point;
  for (l = 0, len = points.length; l < len; l++) {
    point = points[l];
    if (!inRect(sw, ne, point)) {
      return false;
    }
  }
  return true;
};

hasNone = function(sw, ne, points) {
  var l, len, point;
  for (l = 0, len = points.length; l < len; l++) {
    point = points[l];
    if (inRect(sw, ne, point)) {
      return false;
    }
  }
  return true;
};

pretty = function(xoCountResult) {
  var contains, i, l, len, result;
  result = "";
  for (i = l = 0, len = xoCountResult.length; l < len; i = ++l) {
    contains = xoCountResult[i];
    if (contains) {
      result += "V" + (i + 1);
    }
  }
  if (result === "") {
    result = "1";
  }
  return result;
};

oxLib = {
  unknot: [[1, 2], [2, 1]],
  torus: function(p, q) {
    var l, m, o, ref, ref1, ref2, results, results1, results2;
    return [
      (function() {
        results = [];
        for (var l = ref = p + q; ref <= 1 ? l <= 1 : l >= 1; ref <= 1 ? l++ : l--){ results.push(l); }
        return results;
      }).apply(this), (function() {
        results2 = [];
        for (var o = p; p <= 1 ? o <= 1 : o >= 1; p <= 1 ? o++ : o--){ results2.push(o); }
        return results2;
      }).apply(this).concat((function() {
        results1 = [];
        for (var m = ref1 = p + q, ref2 = p + 1; ref1 <= ref2 ? m <= ref2 : m >= ref2; ref1 <= ref2 ? m++ : m--){ results1.push(m); }
        return results1;
      }).apply(this))
    ];
  },
  stab: function(ox, dir, i, perms) {
    var height, j, result;
    result = [];
    height = perms[ox][i - 1];
    result[ox] = (function() {
      var l, len, ref, results;
      ref = perms[ox];
      results = [];
      for (l = 0, len = ref.length; l < len; l++) {
        j = ref[l];
        results.push(j > height ? j + 1 : j);
      }
      return results;
    })();
    result[ox].splice((dir % 2 ? i - 1 : i), 0, height + 1);
    if (dir > 2) {
      height += 1;
    }
    result[1 - ox] = (function() {
      var l, len, ref, results;
      ref = perms[1 - ox];
      results = [];
      for (l = 0, len = ref.length; l < len; l++) {
        j = ref[l];
        results.push(j >= height ? j + 1 : j);
      }
      return results;
    })();
    result[1 - ox].splice((isBetween(1, dir, 4) ? i : i - 1), 0, height);
    return result;
  }
};

grid([[2, 1, 3, 4], [1, 4, 2, 3]]);
